// Generated by `wit-bindgen` 0.25.0. DO NOT EDIT!
// Options used:
#[allow(dead_code)]
pub mod dipankardas011 {
    #[allow(dead_code)]
    pub mod crypto {
        #[allow(dead_code, clippy::all)]
        pub mod password {
            #[used]
            #[doc(hidden)]
            #[cfg(target_arch = "wasm32")]
            static __FORCE_SECTION_REF: fn() =
                super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            #[allow(unused_unsafe, clippy::all)]
            pub fn generate_random(length: u32) -> _rt::String {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "dipankardas011:crypto/password@0.1.0")]
                    extern "C" {
                        #[link_name = "generate-random"]
                        fn wit_import(_: i32, _: *mut u8);
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: i32, _: *mut u8) {
                        unreachable!()
                    }
                    wit_import(_rt::as_i32(&length), ptr0);
                    let l1 = *ptr0.add(0).cast::<*mut u8>();
                    let l2 = *ptr0.add(4).cast::<usize>();
                    let len3 = l2;
                    let bytes3 = _rt::Vec::from_raw_parts(l1.cast(), len3, len3);
                    _rt::string_lift(bytes3)
                }
            }
        }
    }
    #[allow(dead_code)]
    pub mod githubapi {
        #[allow(dead_code, clippy::all)]
        pub mod releases {
            #[used]
            #[doc(hidden)]
            #[cfg(target_arch = "wasm32")]
            static __FORCE_SECTION_REF: fn() =
                super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            #[allow(unused_unsafe, clippy::all)]
            pub fn get_latest_release(org: &str, proj: &str) -> _rt::String {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
                    let vec0 = org;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let vec1 = proj;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "dipankardas011:githubapi/releases@0.1.0")]
                    extern "C" {
                        #[link_name = "get-latest-release"]
                        fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8);
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8) {
                        unreachable!()
                    }
                    wit_import(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2);
                    let l3 = *ptr2.add(0).cast::<*mut u8>();
                    let l4 = *ptr2.add(4).cast::<usize>();
                    let len5 = l4;
                    let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);
                    _rt::string_lift(bytes5)
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn get_contributors(org: &str, proj: &str) -> _rt::String {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 8]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 8]);
                    let vec0 = org;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let vec1 = proj;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "dipankardas011:githubapi/releases@0.1.0")]
                    extern "C" {
                        #[link_name = "get-contributors"]
                        fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8);
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8) {
                        unreachable!()
                    }
                    wit_import(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2);
                    let l3 = *ptr2.add(0).cast::<*mut u8>();
                    let l4 = *ptr2.add(4).cast::<usize>();
                    let len5 = l4;
                    let bytes5 = _rt::Vec::from_raw_parts(l3.cast(), len5, len5);
                    _rt::string_lift(bytes5)
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn get_stars(org: &str, proj: &str) -> u16 {
                unsafe {
                    let vec0 = org;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let vec1 = proj;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();

                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "dipankardas011:githubapi/releases@0.1.0")]
                    extern "C" {
                        #[link_name = "get-stars"]
                        fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize) -> i32;
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize) -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1);
                    ret as u16
                }
            }
        }
    }
    #[allow(dead_code)]
    pub mod openai {
        #[allow(dead_code, clippy::all)]
        pub mod llm {
            #[used]
            #[doc(hidden)]
            #[cfg(target_arch = "wasm32")]
            static __FORCE_SECTION_REF: fn() =
                super::super::super::__link_custom_section_describing_imports;
            #[allow(unused_unsafe, clippy::all)]
            pub fn text_to_text() {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "dipankardas011:openai/llm@0.1.0")]
                    extern "C" {
                        #[link_name = "text-to-text"]
                        fn wit_import();
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import() {
                        unreachable!()
                    }
                    wit_import();
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn text_to_image() {
                unsafe {
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "dipankardas011:openai/llm@0.1.0")]
                    extern "C" {
                        #[link_name = "text-to-image"]
                        fn wit_import();
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import() {
                        unreachable!()
                    }
                    wit_import();
                }
            }
        }
    }
    #[allow(dead_code)]
    pub mod watttime {
        #[allow(dead_code, clippy::all)]
        pub mod watttime {
            #[used]
            #[doc(hidden)]
            #[cfg(target_arch = "wasm32")]
            static __FORCE_SECTION_REF: fn() =
                super::super::super::__link_custom_section_describing_imports;
            use super::super::super::_rt;
            #[derive(Clone)]
            pub struct PointData {
                pub point_time: _rt::String,
                pub value: f32,
            }
            impl ::core::fmt::Debug for PointData {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("PointData")
                        .field("point-time", &self.point_time)
                        .field("value", &self.value)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct MetadataForecast {
                pub data_point_period_seconds: i32,
                pub region: _rt::String,
                pub warnings: _rt::Vec<_rt::String>,
                pub signal_type: _rt::String,
                pub model: _rt::String,
                pub units: _rt::String,
                pub generated_at_period_seconds: i32,
                pub generated_at: _rt::String,
            }
            impl ::core::fmt::Debug for MetadataForecast {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("MetadataForecast")
                        .field("data-point-period-seconds", &self.data_point_period_seconds)
                        .field("region", &self.region)
                        .field("warnings", &self.warnings)
                        .field("signal-type", &self.signal_type)
                        .field("model", &self.model)
                        .field("units", &self.units)
                        .field(
                            "generated-at-period-seconds",
                            &self.generated_at_period_seconds,
                        )
                        .field("generated-at", &self.generated_at)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct MetadataCo2MoerIndex {
                pub data_point_period_seconds: i32,
                pub region: _rt::String,
                pub warnings: _rt::Vec<_rt::String>,
                pub signal_type: _rt::String,
                pub model: _rt::String,
                pub units: _rt::String,
            }
            impl ::core::fmt::Debug for MetadataCo2MoerIndex {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("MetadataCo2MoerIndex")
                        .field("data-point-period-seconds", &self.data_point_period_seconds)
                        .field("region", &self.region)
                        .field("warnings", &self.warnings)
                        .field("signal-type", &self.signal_type)
                        .field("model", &self.model)
                        .field("units", &self.units)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct Forecast {
                pub data: _rt::Vec<PointData>,
                pub meta: MetadataForecast,
            }
            impl ::core::fmt::Debug for Forecast {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("Forecast")
                        .field("data", &self.data)
                        .field("meta", &self.meta)
                        .finish()
                }
            }
            #[derive(Clone)]
            pub struct Co2MoerIndex {
                pub data: PointData,
                pub meta: MetadataCo2MoerIndex,
            }
            impl ::core::fmt::Debug for Co2MoerIndex {
                fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
                    f.debug_struct("Co2MoerIndex")
                        .field("data", &self.data)
                        .field("meta", &self.meta)
                        .finish()
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn register(username: &str, password: &str, email: &str) -> bool {
                unsafe {
                    let vec0 = username;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let vec1 = password;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    let vec2 = email;
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();

                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "dipankardas011:watttime/watttime@0.1.0")]
                    extern "C" {
                        #[link_name = "register"]
                        fn wit_import(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                        ) -> i32;
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                    ) -> i32 {
                        unreachable!()
                    }
                    let ret = wit_import(
                        ptr0.cast_mut(),
                        len0,
                        ptr1.cast_mut(),
                        len1,
                        ptr2.cast_mut(),
                        len2,
                    );
                    _rt::bool_lift(ret as u8)
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn get_token() -> Option<_rt::String> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 12]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
                    let ptr0 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "dipankardas011:watttime/watttime@0.1.0")]
                    extern "C" {
                        #[link_name = "get-token"]
                        fn wit_import(_: *mut u8);
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8) {
                        unreachable!()
                    }
                    wit_import(ptr0);
                    let l1 = i32::from(*ptr0.add(0).cast::<u8>());
                    match l1 {
                        0 => None,
                        1 => {
                            let e = {
                                let l2 = *ptr0.add(4).cast::<*mut u8>();
                                let l3 = *ptr0.add(8).cast::<usize>();
                                let len4 = l3;
                                let bytes4 = _rt::Vec::from_raw_parts(l2.cast(), len4, len4);

                                _rt::string_lift(bytes4)
                            };
                            Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn get_region(token: &str, signal_type: &str) -> Option<_rt::String> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 12]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 12]);
                    let vec0 = token;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let vec1 = signal_type;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    let ptr2 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "dipankardas011:watttime/watttime@0.1.0")]
                    extern "C" {
                        #[link_name = "get-region"]
                        fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8);
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(_: *mut u8, _: usize, _: *mut u8, _: usize, _: *mut u8) {
                        unreachable!()
                    }
                    wit_import(ptr0.cast_mut(), len0, ptr1.cast_mut(), len1, ptr2);
                    let l3 = i32::from(*ptr2.add(0).cast::<u8>());
                    match l3 {
                        0 => None,
                        1 => {
                            let e = {
                                let l4 = *ptr2.add(4).cast::<*mut u8>();
                                let l5 = *ptr2.add(8).cast::<usize>();
                                let len6 = l5;
                                let bytes6 = _rt::Vec::from_raw_parts(l4.cast(), len6, len6);

                                _rt::string_lift(bytes6)
                            };
                            Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn get_forecast(token: &str, region: &str, signal_type: &str) -> Option<Forecast> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 68]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 68]);
                    let vec0 = token;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let vec1 = region;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    let vec2 = signal_type;
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    let ptr3 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "dipankardas011:watttime/watttime@0.1.0")]
                    extern "C" {
                        #[link_name = "get-forecast"]
                        fn wit_import(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        );
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    wit_import(
                        ptr0.cast_mut(),
                        len0,
                        ptr1.cast_mut(),
                        len1,
                        ptr2.cast_mut(),
                        len2,
                        ptr3,
                    );
                    let l4 = i32::from(*ptr3.add(0).cast::<u8>());
                    match l4 {
                        0 => None,
                        1 => {
                            let e = {
                                let l5 = *ptr3.add(4).cast::<*mut u8>();
                                let l6 = *ptr3.add(8).cast::<usize>();
                                let base11 = l5;
                                let len11 = l6;
                                let mut result11 = _rt::Vec::with_capacity(len11);
                                for i in 0..len11 {
                                    let base = base11.add(i * 12);
                                    let e11 = {
                                        let l7 = *base.add(0).cast::<*mut u8>();
                                        let l8 = *base.add(4).cast::<usize>();
                                        let len9 = l8;
                                        let bytes9 =
                                            _rt::Vec::from_raw_parts(l7.cast(), len9, len9);
                                        let l10 = *base.add(8).cast::<f32>();

                                        PointData {
                                            point_time: _rt::string_lift(bytes9),
                                            value: l10,
                                        }
                                    };
                                    result11.push(e11);
                                }
                                _rt::cabi_dealloc(base11, len11 * 12, 4);
                                let l12 = *ptr3.add(12).cast::<i32>();
                                let l13 = *ptr3.add(16).cast::<*mut u8>();
                                let l14 = *ptr3.add(20).cast::<usize>();
                                let len15 = l14;
                                let bytes15 = _rt::Vec::from_raw_parts(l13.cast(), len15, len15);
                                let l16 = *ptr3.add(24).cast::<*mut u8>();
                                let l17 = *ptr3.add(28).cast::<usize>();
                                let base21 = l16;
                                let len21 = l17;
                                let mut result21 = _rt::Vec::with_capacity(len21);
                                for i in 0..len21 {
                                    let base = base21.add(i * 8);
                                    let e21 = {
                                        let l18 = *base.add(0).cast::<*mut u8>();
                                        let l19 = *base.add(4).cast::<usize>();
                                        let len20 = l19;
                                        let bytes20 =
                                            _rt::Vec::from_raw_parts(l18.cast(), len20, len20);

                                        _rt::string_lift(bytes20)
                                    };
                                    result21.push(e21);
                                }
                                _rt::cabi_dealloc(base21, len21 * 8, 4);
                                let l22 = *ptr3.add(32).cast::<*mut u8>();
                                let l23 = *ptr3.add(36).cast::<usize>();
                                let len24 = l23;
                                let bytes24 = _rt::Vec::from_raw_parts(l22.cast(), len24, len24);
                                let l25 = *ptr3.add(40).cast::<*mut u8>();
                                let l26 = *ptr3.add(44).cast::<usize>();
                                let len27 = l26;
                                let bytes27 = _rt::Vec::from_raw_parts(l25.cast(), len27, len27);
                                let l28 = *ptr3.add(48).cast::<*mut u8>();
                                let l29 = *ptr3.add(52).cast::<usize>();
                                let len30 = l29;
                                let bytes30 = _rt::Vec::from_raw_parts(l28.cast(), len30, len30);
                                let l31 = *ptr3.add(56).cast::<i32>();
                                let l32 = *ptr3.add(60).cast::<*mut u8>();
                                let l33 = *ptr3.add(64).cast::<usize>();
                                let len34 = l33;
                                let bytes34 = _rt::Vec::from_raw_parts(l32.cast(), len34, len34);

                                Forecast {
                                    data: result11,
                                    meta: MetadataForecast {
                                        data_point_period_seconds: l12,
                                        region: _rt::string_lift(bytes15),
                                        warnings: result21,
                                        signal_type: _rt::string_lift(bytes24),
                                        model: _rt::string_lift(bytes27),
                                        units: _rt::string_lift(bytes30),
                                        generated_at_period_seconds: l31,
                                        generated_at: _rt::string_lift(bytes34),
                                    },
                                }
                            };
                            Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    }
                }
            }
            #[allow(unused_unsafe, clippy::all)]
            pub fn get_current_co2_moer_index(
                token: &str,
                region: &str,
                signal_type: &str,
            ) -> Option<Co2MoerIndex> {
                unsafe {
                    #[repr(align(4))]
                    struct RetArea([::core::mem::MaybeUninit<u8>; 60]);
                    let mut ret_area = RetArea([::core::mem::MaybeUninit::uninit(); 60]);
                    let vec0 = token;
                    let ptr0 = vec0.as_ptr().cast::<u8>();
                    let len0 = vec0.len();
                    let vec1 = region;
                    let ptr1 = vec1.as_ptr().cast::<u8>();
                    let len1 = vec1.len();
                    let vec2 = signal_type;
                    let ptr2 = vec2.as_ptr().cast::<u8>();
                    let len2 = vec2.len();
                    let ptr3 = ret_area.0.as_mut_ptr().cast::<u8>();
                    #[cfg(target_arch = "wasm32")]
                    #[link(wasm_import_module = "dipankardas011:watttime/watttime@0.1.0")]
                    extern "C" {
                        #[link_name = "get-current-CO2-MOER-index"]
                        fn wit_import(
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                            _: usize,
                            _: *mut u8,
                        );
                    }

                    #[cfg(not(target_arch = "wasm32"))]
                    fn wit_import(
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                        _: usize,
                        _: *mut u8,
                    ) {
                        unreachable!()
                    }
                    wit_import(
                        ptr0.cast_mut(),
                        len0,
                        ptr1.cast_mut(),
                        len1,
                        ptr2.cast_mut(),
                        len2,
                        ptr3,
                    );
                    let l4 = i32::from(*ptr3.add(0).cast::<u8>());
                    match l4 {
                        0 => None,
                        1 => {
                            let e = {
                                let l5 = *ptr3.add(4).cast::<*mut u8>();
                                let l6 = *ptr3.add(8).cast::<usize>();
                                let len7 = l6;
                                let bytes7 = _rt::Vec::from_raw_parts(l5.cast(), len7, len7);
                                let l8 = *ptr3.add(12).cast::<f32>();
                                let l9 = *ptr3.add(16).cast::<i32>();
                                let l10 = *ptr3.add(20).cast::<*mut u8>();
                                let l11 = *ptr3.add(24).cast::<usize>();
                                let len12 = l11;
                                let bytes12 = _rt::Vec::from_raw_parts(l10.cast(), len12, len12);
                                let l13 = *ptr3.add(28).cast::<*mut u8>();
                                let l14 = *ptr3.add(32).cast::<usize>();
                                let base18 = l13;
                                let len18 = l14;
                                let mut result18 = _rt::Vec::with_capacity(len18);
                                for i in 0..len18 {
                                    let base = base18.add(i * 8);
                                    let e18 = {
                                        let l15 = *base.add(0).cast::<*mut u8>();
                                        let l16 = *base.add(4).cast::<usize>();
                                        let len17 = l16;
                                        let bytes17 =
                                            _rt::Vec::from_raw_parts(l15.cast(), len17, len17);

                                        _rt::string_lift(bytes17)
                                    };
                                    result18.push(e18);
                                }
                                _rt::cabi_dealloc(base18, len18 * 8, 4);
                                let l19 = *ptr3.add(36).cast::<*mut u8>();
                                let l20 = *ptr3.add(40).cast::<usize>();
                                let len21 = l20;
                                let bytes21 = _rt::Vec::from_raw_parts(l19.cast(), len21, len21);
                                let l22 = *ptr3.add(44).cast::<*mut u8>();
                                let l23 = *ptr3.add(48).cast::<usize>();
                                let len24 = l23;
                                let bytes24 = _rt::Vec::from_raw_parts(l22.cast(), len24, len24);
                                let l25 = *ptr3.add(52).cast::<*mut u8>();
                                let l26 = *ptr3.add(56).cast::<usize>();
                                let len27 = l26;
                                let bytes27 = _rt::Vec::from_raw_parts(l25.cast(), len27, len27);

                                Co2MoerIndex {
                                    data: PointData {
                                        point_time: _rt::string_lift(bytes7),
                                        value: l8,
                                    },
                                    meta: MetadataCo2MoerIndex {
                                        data_point_period_seconds: l9,
                                        region: _rt::string_lift(bytes12),
                                        warnings: result18,
                                        signal_type: _rt::string_lift(bytes21),
                                        model: _rt::string_lift(bytes24),
                                        units: _rt::string_lift(bytes27),
                                    },
                                }
                            };
                            Some(e)
                        }
                        _ => _rt::invalid_enum_discriminant(),
                    }
                }
            }
        }
    }
}
mod _rt {
    pub use alloc_crate::string::String;

    pub fn as_i32<T: AsI32>(t: T) -> i32 {
        t.as_i32()
    }

    pub trait AsI32 {
        fn as_i32(self) -> i32;
    }

    impl<'a, T: Copy + AsI32> AsI32 for &'a T {
        fn as_i32(self) -> i32 {
            (*self).as_i32()
        }
    }

    impl AsI32 for i32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }

    impl AsI32 for u32 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }

    impl AsI32 for i16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }

    impl AsI32 for u16 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }

    impl AsI32 for i8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }

    impl AsI32 for u8 {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }

    impl AsI32 for char {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }

    impl AsI32 for usize {
        #[inline]
        fn as_i32(self) -> i32 {
            self as i32
        }
    }
    pub use alloc_crate::vec::Vec;
    pub unsafe fn string_lift(bytes: Vec<u8>) -> String {
        if cfg!(debug_assertions) {
            String::from_utf8(bytes).unwrap()
        } else {
            String::from_utf8_unchecked(bytes)
        }
    }
    pub unsafe fn bool_lift(val: u8) -> bool {
        if cfg!(debug_assertions) {
            match val {
                0 => false,
                1 => true,
                _ => panic!("invalid bool discriminant"),
            }
        } else {
            val != 0
        }
    }
    pub unsafe fn invalid_enum_discriminant<T>() -> T {
        if cfg!(debug_assertions) {
            panic!("invalid enum discriminant")
        } else {
            core::hint::unreachable_unchecked()
        }
    }
    pub unsafe fn cabi_dealloc(ptr: *mut u8, size: usize, align: usize) {
        if size == 0 {
            return;
        }
        let layout = alloc::Layout::from_size_align_unchecked(size, align);
        alloc::dealloc(ptr as *mut u8, layout);
    }
    extern crate alloc as alloc_crate;
    pub use alloc_crate::alloc;
}

#[cfg(target_arch = "wasm32")]
#[link_section = "component-type:wit-bindgen:0.25.0:app:encoded world"]
#[doc(hidden)]
pub static __WIT_BINDGEN_COMPONENT_TYPE: [u8; 1074] = *b"\
\0asm\x0d\0\x01\0\0\x19\x16wit-component-encoding\x04\0\x07\xb8\x07\x01A\x02\x01\
A\x08\x01B\x02\x01@\x01\x06lengthy\0s\x04\0\x0fgenerate-random\x01\0\x03\x01$dip\
ankardas011:crypto/password@0.1.0\x05\0\x01B\x05\x01@\x02\x03orgs\x04projs\0s\x04\
\0\x12get-latest-release\x01\0\x04\0\x10get-contributors\x01\0\x01@\x02\x03orgs\x04\
projs\0{\x04\0\x09get-stars\x01\x01\x03\x01'dipankardas011:githubapi/releases@0.\
1.0\x05\x01\x01B\x03\x01@\0\x01\0\x04\0\x0ctext-to-text\x01\0\x04\0\x0dtext-to-i\
mage\x01\0\x03\x01\x1fdipankardas011:openai/llm@0.1.0\x05\x02\x01B\x19\x01r\x02\x0a\
point-times\x05valuev\x04\0\x0apoint-data\x03\0\0\x01ps\x01r\x08\x19data-point-p\
eriod-secondsz\x06regions\x08warnings\x02\x0bsignal-types\x05models\x05unitss\x1b\
generated-at-period-secondsz\x0cgenerated-ats\x04\0\x11metadata-forecast\x03\0\x03\
\x01r\x06\x19data-point-period-secondsz\x06regions\x08warnings\x02\x0bsignal-typ\
es\x05models\x05unitss\x04\0\x17metadata-co2-moer-index\x03\0\x05\x01p\x01\x01r\x02\
\x04data\x07\x04meta\x04\x04\0\x08forecast\x03\0\x08\x01r\x02\x04data\x01\x04met\
a\x06\x04\0\x0eco2-moer-index\x03\0\x0a\x01@\x03\x08usernames\x08passwords\x05em\
ails\0\x7f\x04\0\x08register\x01\x0c\x01ks\x01@\0\0\x0d\x04\0\x09get-token\x01\x0e\
\x01@\x02\x05tokens\x0bsignal-types\0\x0d\x04\0\x0aget-region\x01\x0f\x01k\x09\x01\
@\x03\x05tokens\x06regions\x0bsignal-types\0\x10\x04\0\x0cget-forecast\x01\x11\x01\
k\x0b\x01@\x03\x05tokens\x06regions\x0bsignal-types\0\x12\x04\0\x1aget-current-C\
O2-MOER-index\x01\x13\x03\x01&dipankardas011:watttime/watttime@0.1.0\x05\x03\x04\
\x01\x16dipankardas011:cli/app\x04\0\x0b\x09\x01\0\x03app\x03\0\0\0G\x09producer\
s\x01\x0cprocessed-by\x02\x0dwit-component\x070.208.1\x10wit-bindgen-rust\x060.2\
5.0";

#[inline(never)]
#[doc(hidden)]
#[cfg(target_arch = "wasm32")]
pub fn __link_custom_section_describing_imports() {
    wit_bindgen_rt::maybe_link_cabi_realloc();
}
